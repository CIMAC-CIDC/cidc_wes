#module: neoantigen prediction module using pvacseq pipeline (from pvactools)

_neoantigen_threads=64 #should be set to as max cores; w/ 64 runtime~=1hr

def neoantigen_runsHelper(wildcards, iindex):
    """Given a snakemake wildcards, an iindex - 0 for Normal, 1 for Tumor,
    returns the sample name of Normal (if iindex=0) else sample name of Tmr"""
    tmp = []
    r = config['runs'][wildcards.run]
    #print(r)

    #check that we have a valid pair
    if len(r) >=2:
        sample_name = r[iindex]
        tmp.append(sample_name) 
    else:
        #NOTE: I can't figure out a proper kill command so I'll do this
        tmp=["ERROR! BAD pairing for run--requires at least two samples: %s" % (wildcards.run)]
    #print(tmp)
    return tmp


def neoantigen_getNormal(wildcards):
    return neoantigen_runsHelper(wildcards, 0)

def neoantigen_getTumor(wildcards):
    return neoantigen_runsHelper(wildcards, 1)

def neoantigen_targets(wildcards):
    """Generates the targets for this module"""
    ls = []
    for run in config['runs']:
        tumor = config['runs'][run][1] 
        ls.append("analysis/neoantigen/%s/MHC_Class_I/%s.filtered.condensed.ranked.tsv" % (run,tumor))
        ls.append("analysis/neoantigen/%s/MHC_Class_I/%s.filtered.condensed.ranked.addSample.tsv" % (run,tumor))

        #output file map
        ls.append("analysis/neoantigen/%s/%s.neoantigen.output.yaml" % (run,run))
        ls.append("analysis/neoantigen/%s/%s_neoantigen_table.tsv" % (run,run))
        ls.append("analysis/report/json/neoantigen/%s.neoantigen.json" % (run))

    return ls

def neoantigen_output_files(wildcards):
    """returns a list of filepaths generated by this module to store 
    in the CIDC for a given sample 
    """
    ls = []
    run = wildcards.run
    tumor = config['runs'][run][1]
    ls.append("analysis/neoantigen/%s/MHC_Class_I/%s.filtered.tsv" % (run,tumor))
    ls.append("analysis/neoantigen/%s/MHC_Class_I/%s.filtered.condensed.ranked.tsv" % (run,tumor))
    ls.append("analysis/neoantigen/%s/MHC_Class_I/%s.all_epitopes.tsv" % (run,tumor))

    if 'neoantigen_run_classII' in config and config['neoantigen_run_classII']:
        #return classII results and combined
        ls.append("analysis/neoantigen/%s/MHC_Class_II/%s.filtered.tsv" % (run,tumor))
        ls.append("analysis/neoantigen/%s/MHC_Class_II/%s.filtered.condensed.ranked.tsv" % (run,tumor))
        ls.append("analysis/neoantigen/%s/MHC_Class_II/%s.all_epitopes.tsv" % (run,tumor))

        #Also combined
        ls.append("analysis/neoantigen/%s/combined/%s.filtered.tsv" % (run,tumor))
        ls.append("analysis/neoantigen/%s/combined/%s.filtered.condensed.ranked.tsv" % (run,tumor))
        ls.append("analysis/neoantigen/%s/combined/%s.all_epitopes.tsv" % (run,tumor))
    return ls

def neoantigen_get_output_keys(wildcards):
    ls = ['classI_ranked_epitopes','classI_all_epitopes']
    if 'neoantigen_run_classII' in config and config['neoantigen_run_classII']:
        ls.extend(['classII_ranked_epitopes','classII_all_epitopes',
                   'combined_ranked_epitopes','combined_all_epitopes'])
    return ls

def neoantigen_getNeoantigenList_helper(wildcards):
    ls = []
    run = wildcards.run
    tumor = neoantigen_getTumor(wildcards)[0]

    if config.get('neoantigen_run_classII'):
        ls.append("analysis/neoantigen/%s/combined/%s.filtered.condensed.ranked.tsv" % (run,tumor))
    else:
        ls.append("analysis/neoantigen/%s/MHC_Class_I/%s.filtered.condensed.ranked.tsv" % (run,tumor))
    return ls

rule neoantigen_make_file_map:
    input:
        neoantigen_output_files
    output:
        "analysis/neoantigen/{run}/{run}.neoantigen.output.yaml"
    benchmark: "benchmarks/neoantigen/{run}/{run}.neoantigen_make_file_map.txt"
    params:
        run = lambda wildcards: wildcards.run,
        kkeys = lambda wildcards: " -k ".join(neoantigen_get_output_keys(wildcards)),
        files = lambda wildcards, input: " -f ".join(input),
    shell:
        "cidc_wes/modules/scripts/yaml_writer.py -t runs -n {params.run} -k {params.kkeys} -f {params.files} > {output}"


def getPvacseqOut(wildcards):
    """returns tuple (run, tumor sample name)"""
    run = wildcards.run
    tumor = config['runs'][run][1]
    return(run,tumor)

def getTumorHLA(wildcards):
    """get the optitype results file for the tumor sample"""
    run = wildcards.run
    tumor = config['runs'][run][1]
    ls = ["analysis/optitype/%s/%s_result.tsv" % (tumor, tumor)]
    if 'neoantigen_run_classII' in config and config['neoantigen_run_classII']:
        ls.append("analysis/xhla/%s/report-%s-hla.json" % (tumor,tumor))
    #print(ls)
    return ls

def parseHLA(hla_files):
    """Given an optitypes '_results.tsv' file; parses the HLA A, B, C
    and returns these as a comma-separated string (for pvacseq) input

    NOTE: cureently the optitype results.tsv looks somthing like this:
    	A1	A2	B1	B2	C1	C2	Reads	Objective
    0					C*06:04	C*06:04	4.0	3.99
    **So were' going to parse cols 1-6 and return that"""

    #CATCH when the HLA does not exist yet
    #print(optitype_out_file)
    optitype_out_file = hla_files[0]
    if not os.path.exists(optitype_out_file):
        #print("WES WARNING: %s is not found!" % optitype_out_file)
        return ""

    f = open(optitype_out_file)
    hdr = f.readline().strip().split("\t") #ignore for now
    classI = f.readline().strip().split("\t")[1:7] #want first 6 cols
    #FOR classI alleles, prepend a HLA to each of them
    classI = ["HLA-%s" % a for a in classI if a]
    #print(classI)
    f.close()
    
    #check for xhla file
    classII = []
    if 'neoantigen_run_classII' in config and config['neoantigen_run_classII'] and len(hla_files) > 1:
        xhla_out_file = hla_files[1]
        
        #PARSE xhla json file...
        if os.path.exists(xhla_out_file):
            f = open(xhla_out_file)
            xhla_out = json.load(f)
            f.close()

            #build classII alleleles
            #ONLY add class II alleles--i.e. ones that start with "D"
            classII = [a for a in xhla_out['hla']['alleles'] if a.startswith("D")]
        #print(classII)
        
    if classII:
        classI.extend(classII)
    #NOTE: NOW classI has all hla alleles (including classII if opted for)
    hla = ",".join(["%s" % a for a in classI if a])
    #print(hla)
    return hla

def getVCF_file(wildcards):
    """IF there is expression data available, return the expression-added VCF
    otherwise return the neoantigen prepared vcf"""
    
    run = wildcards.run
    tumor_sample = config['runs'][run][1]
    caller = config.get("somatic_caller", "tnscope")

    #Default return
    ret = "analysis/somatic/%s/%s_%s.filter.neoantigen.vep.vcf" % (run, run, caller)

    rna = config.get('rna', None)
    
    if rna and rna.get(tumor_sample, None):
        #NOT to be confused with analysis/rna/{run}/{run}_{caller}...same!!
        ret = "analysis/somatic/%s/%s_%s.filter.neoantigen.vep.rna.vcf" % (run, run, caller)

    return ret
    

rule neoantigen_all:
    input:
        neoantigen_targets
    benchmark: "benchmarks/neoantigen/neoantigen_all.txt"

rule neoantigen_vep_annotate:
    input:
        "analysis/somatic/{run}/{run}_{caller}.filter.vcf"
    output:
        "analysis/somatic/{run}/{run}_{caller}.filter.neoantigen.vep.vcf"
    params:
        index=config['genome_fasta'],
        vep_data=config['vep_data'],
        vep_plugins=config['vep_plugins'],

        #normal = lambda wildcards: config['runs'][wildcards.run][0],
        #tumor = lambda wildcards: config['runs'][wildcards.run][1],
    group: "neoantigen"
    conda: "../envs/somatic_vcftools.yml"
    benchmark:
        "benchmarks/neoantigen/{run}/{run}_{caller}.neoantigen_vep_annotate.txt"
    shell:
        """vep --input_file {input} --output_file {output} --format vcf --vcf --symbol --terms SO --tsl --hgvs --fasta {params.index} --offline --cache --dir_cache {params.vep_data} --plugin Downstream --plugin Wildtype --dir_plugins {params.vep_plugins} --pick"""

rule neoantigen_bzipAndtabix:
    input:
        "analysis/somatic/{run}/{run}_{caller}.filter.neoantigen.vep.vcf"
    output:
        gz="analysis/somatic/{run}/{run}_{caller}.filter.neoantigen.vep.vcf.gz",
        tbi="analysis/somatic/{run}/{run}_{caller}.filter.neoantigen.vep.vcf.gz.tbi",
    group: "neoantigen"
    benchmark:
        "benchmarks/neoantigen/{run}/{run}_{caller}.neoantigen_bzipAndtabix.txt"
    shell:
        "bgzip -c {input} > {output.gz} && tabix -p vcf {output.gz}"


def getExpressionFile(wildcards):
    run = wildcards.run
    tumor_sample = config['runs'][run][1]
    rna = config['rna']
    expr_file = rna[tumor_sample]['expression_file']
    return expr_file

rule neoantigen_formatIds:
    """Changes ensembl transcript ids in the salmon files from
    ENST00000456328.2 to ENST00000456328--removing the suffix .X"""
    input:
        getExpressionFile,
    output: #modified salmon expression file
        "analysis/neoantigen/{run}/{run}.format.quant.sf"
    params:
        awk_cmd = "awk \'{gsub(/\\.[[:digit:]]/,\"\", $1)}1\'",
    group: "neoantigen"
    #conda: "../envs/somatic_vcftools.yml"
    benchmark:
        "benchmarks/neoantigen/{run}/{run}.neoantigen_formatiIds.txt"
    shell:
        """{params.awk_cmd} {input} > {output}"""

rule neoantigen_expression_annotator:
    """Add expression to intersect set of WES and RNA variants; only run
    IF RNA is part of the WES run"""
    input:
        vcf="analysis/rna/{run}/{run}_{caller}.filter.neoantigen.vep.rna.vcf",
        salmon="analysis/neoantigen/{run}/{run}.format.quant.sf",
    output:
        "analysis/somatic/{run}/{run}_{caller}.filter.neoantigen.vep.rna.vcf"
    params:
        iid = "Name", #id col = 'Name'
        tumorName = lambda wildcards: config['runs'][wildcards.run][1],
        exprCol = "TPM", #expression col = 'TPM
    group: "neoantigen"
    #conda: ...
    benchmark:
        "benchmarks/neoantigen/{run}/{run}_{caller}.neoantigen_expression_annotator.txt"
    shell:
        """vcf-expression-annotator -i {params.iid} -s {params.tumorName} -e {params.exprCol} -o {output} {input.vcf} {input.salmon} custom transcript"""

if not config.get('neoantigen_run_classII'):
    rule neoantigen_pvacseq:
        """NOTE: neoantigen's pvacseq is not available on CONDA
        MUST either be installed in base system/docker container"""
        input:
            vcf=getVCF_file,
            hla=getTumorHLA,
        output:
            main="analysis/neoantigen/{run}/MHC_Class_I/{tumor}.filtered.condensed.ranked.tsv",
            #OTHERS:
            filtered="analysis/neoantigen/{run}/MHC_Class_I/{tumor}.filtered.tsv",
            all_epitopes="analysis/neoantigen/{run}/MHC_Class_I/{tumor}.all_epitopes.tsv",
        params:
            normal = lambda wildcards: "--normal-sample-name %s" % config['runs'][wildcards.run][0] if not config.get('tumor_only') else "",
            tumor = lambda wildcards: config['runs'][wildcards.run][1],
            iedb = config['neoantigen_iedb'],
            HLA = lambda wildcards,input: parseHLA(input.hla),
            callers=config.get('neoantigen_callers','NetMHCpan NetMHCcons MHCflurry NetMHCIIpan'),
            epitope_lengths=config.get('neoantigen_epitope_lengths', '8,9,10,11'),
            output_dir = lambda wildcards: "%sanalysis/neoantigen/%s/" % (config['remote_path'], wildcards.run),
        threads: 64 #_neoantigen_threads
        group: "neoantigen"
        log: "analysis/logs/neoantigen/{run}/{tumor}.neoantigen_pvacseq.log"
        benchmark:
            "benchmarks/neoantigen/{run}/{tumor}.neoantigen_pvacseq.txt"
        shell:
            """pvacseq run {input.vcf} {params.tumor} {params.HLA} {params.callers} {params.output_dir} -e {params.epitope_lengths} -t {threads} {params.normal} --iedb-install-directory {params.iedb} 2> {log}"""
else: #EXPECT class II output
    rule neoantigen_pvacseq:
        """NOTE: neoantigen's pvacseq is not available on CONDA
        MUST either be installed in base system/docker container"""
        input:
            vcf=getVCF_file,
            hla=getTumorHLA,
        output:
            main="analysis/neoantigen/{run}/MHC_Class_I/{tumor}.filtered.condensed.ranked.tsv",
            #OTHERS:
            filtered="analysis/neoantigen/{run}/MHC_Class_I/{tumor}.filtered.tsv",
            all_epitopes="analysis/neoantigen/{run}/MHC_Class_I/{tumor}.all_epitopes.tsv",
            main2="analysis/neoantigen/{run}/MHC_Class_II/{tumor}.filtered.condensed.ranked.tsv",
            filtered2="analysis/neoantigen/{run}/MHC_Class_II/{tumor}.filtered.tsv",
            all_epitopes2="analysis/neoantigen/{run}/MHC_Class_II/{tumor}.all_epitopes.tsv",
            main3="analysis/neoantigen/{run}/combined/{tumor}.filtered.condensed.ranked.tsv",
            filtered3="analysis/neoantigen/{run}/combined/{tumor}.filtered.tsv",
            all_epitopes3="analysis/neoantigen/{run}/combined/{tumor}.all_epitopes.tsv",

        params:
            normal = lambda wildcards: "--normal-sample-name %s" % config['runs'][wildcards.run][0] if not config.get('tumor_only') else "",
            tumor = lambda wildcards: config['runs'][wildcards.run][1],
            iedb = config['neoantigen_iedb'],
            HLA = lambda wildcards,input: parseHLA(input.hla),
            callers=config.get('neoantigen_callers','NetMHCpan NetMHCcons MHCflurry NetMHCIIpan'),
            epitope_lengths=config.get('neoantigen_epitope_lengths', '8,9,10,11'),
            output_dir = lambda wildcards: "%sanalysis/neoantigen/%s/" % (config['remote_path'], wildcards.run),
        threads: 64 #_neoantigen_threads
        group: "neoantigen"
        log: "analysis/logs/neoantigen/{run}/{tumor}.neoantigen_pvacseq.log"
        benchmark:
            "benchmarks/neoantigen/{run}/{tumor}.neoantigen_pvacseq.txt"
        shell:
            """pvacseq run {input.vcf} {params.tumor} {params.HLA} {params.callers} {params.output_dir} -e {params.epitope_lengths} -t {threads} {params.normal} --iedb-install-directory {params.iedb} 2> {log}"""

  
rule neoantigen_add_sample:
    """Takes the {tumor}.filtered.condensed.ranked.tsv file and adds a first
    col, Sample which is set to the RUN name (not the sample name!)
    to be used for pvacseq_plot.R"""
    input:
        "analysis/neoantigen/{run}/MHC_Class_I/{tumor}.filtered.condensed.ranked.tsv"
    output:
        "analysis/neoantigen/{run}/MHC_Class_I/{tumor}.filtered.condensed.ranked.addSample.tsv"
    params:
        run_name = lambda wildcards: wildcards.run
    benchmark:
        "benchmarks/neoantigen/{run}/{tumor}.neoantigen_add_sample.txt"
    group: "neoantigen"
    shell:
        "cidc_wes/modules/scripts/neoantigen_addSample.py -f {input} -n {params.run_name} -o {output}"

rule neoantigen_getNeoantigenList:
    """Reads through the appropriate filtered.tsv file and generate a table of 
    neoantigens"""
    input:
        neoantigen_getNeoantigenList_helper
    output:
        "analysis/neoantigen/{run}/{run}_neoantigen_table.tsv"
    benchmark:
        "benchmarks/neoantigen/{run}/{run}.neoantigen_getNeoantigenList.txt"
    group: "neoantigen"
    shell:
        "cidc_wes/modules/scripts/neoantigen_getNeoantgnList.py -f {input} -o {output}"

def neoangient_json_helper(wildcards):
    run = wildcards.run
    tumor = config['runs'][run][1]

    if 'neoantigen_run_classII' in config and config['neoantigen_run_classII']:
        ls = ["analysis/neoantigen/%s/combined/%s.filtered.tsv" % (run,tumor)]
    else:
        ls = ["analysis/neoantigen/%s/MHC_Class_I/%s.filtered.tsv" % (run,tumor)]
    return ls
    
rule neoantigen_json:
    """Generates the module's json section
    Includes the filter.tsv results
    """
    input:
        neoangient_json_helper
    output:
        "analysis/report/json/neoantigen/{run}.neoantigen.json"
    params:
        run = lambda wildcards: wildcards.run
    group: "neoantigen"
    benchmark:
        "benchmarks/neoantigen/{run}.neoantigen_json.txt"
    shell:
        "cidc_wes/modules/scripts/json_neoantigen.py -r {params.run} -f {input} -o {output}"

